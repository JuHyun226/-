// ch05_pointer.cpp

#include <iostream>

using namespace std;

/*
포인터
= 메모리의 주소값을 저장하는 변수: 실수 정수 다 안 되고 오로지 주소만 저장
*/


//변수의 메모리 주소를 구해보았는데 메모리 주소는 어디에 저장해야 할까요? C 언어에서 메모리 주소는 포인터(pointer) 변수에 저장합니다.

다음과 같이 포인터 변수는* 를 사용하여 선언합니다(포인터 변수는 포인터로 줄여서 부르기도 합니다).

/* 표기
자료형* 포인터이름;
포인터 = &변수;
*/
/* 이해를 돕는 외부 파일

#include <stdio.h>

int main()
{
	int *numPtr;      // 포인터 변수 선언
	int num1 = 10;    // int형 변수를 선언하고 10 저장

	numPtr = &num1;   // num1의 메모리 주소를 포인터 변수에 저장

	printf("%p\n", numPtr);    // 0055FC24: 포인터 변수 numPtr의 값 출력
							   // 컴퓨터마다, 실행할 때마다 달라짐
	printf("%p\n", &num1);     // 0055FC24: 변수 num1의 메모리 주소 출력
							   // 컴퓨터마다, 실행할 때마다 달라짐

	return 0;
}

*/
int main() {

	int a = 10;
	int* pa = &a;
	cout << "a 주소 : " << &a << " == pa 값 : " << pa << endl;
	// 주소값을 가진 애가 pointer 변수 pa도 있다.
	cout << "a 값 : " << a << " == *pa : " << *pa << endl;
	//a의 값을 쓸때는 그냥  a라고 쓰면 됨.
	// 근데 변수 a의 값을 쓸 수 있는 방법이 하나 더 있는데,
	// 주소를 알면 해당 공간의 값을 사용할 수 있음.
	// 포인터변수를 초기화 한 후 앞에 별(역첨자연산자? '*')를 붙이면 됨

	*pa = 111;
	cout << "a 값 : " << a << " == *pa : " << *pa << endl;
	// 111을 넣어라고 하면 이 밑의 값이 바뀜.
	// a라는 공간에 F0을 넣었는데 pa라는 주소공간에 f0을 넣고,
	// 얘를 *pa로 역첨자연산자를 사용하면 f0는 111로 바껴서 들어감

}

//----------------------------------------------


int main() {

	int v;
	int* pv = &v;
	cout << "pv    : " << pv << endl;
	cout << "pv + 1 : " << pv + 1 << endl;
	//주소도 연산이 됨
	// 기준은 그 주소의 자료형 크기 단위. 
	만약 cout << "pv + 2 : " << pv + 2 << endl;
    // 이러면 주소값이 8 증가하게 됨
	// 주소는 16진수 형태.
	cout << endl;



//---만약 더블형 변수일때

	double d;
	double* pd = &d;
	cout << "pd     : " << pd << endl;
	//pd의 값을 출력하면 어떤 주소가 나올 거고, 얘를 연산처리하면
	cout << "pd + 1 : " << pd + 1 << endl;
	cout << "pd + 2 : " << pd + 2 << endl;

	//double 형 변수니 주소가 8씩 바뀜.

}

//----배열: 같은 형의 값 여러 개 & 인덱스------------------------------------------

int main() {

	int ar[] = { 1, 2, 3 };
	int* p = ar;
		
	// ar  [0]   [1]   [2]            p
	//   |  1  |  2  |  3  |           | A0 |(초기화 시킴)
	//  A0    A4    A8
	// ar           (A0) ==  p         (A0)
	// ar + 1       (A4) ==  p + 1     (A4)
	// *(ar + 1)    (2)  == *(p + 1)   (2)
	// ar[1]        (2)  == p[1]       (2)

	int ar_size = sizeof(ar) / sizeof(int);
	for (int i = 0; i < ar_size; i++) {
		cout << "[" << i << "] : " << ar[i] << ", " << *(ar + i) << ", " << *(p + i) << ", " << p[i] << endl;

	}
	cout << endl;


	// 시작주소가 A0이면 그다음은 A4 그다음은 A8이 됨.
	// ar이 가진 값은 초기 주소니 당연히 (A0) == p  
	// ar + 1 가능
	//인덱스 번호는 포인터 연산의 접근을 쉽게 만들어줌.

	// ar += 1; error 왜냐면 주소가 상수라서 값을 변경하면 안됌.
	// 그냥 ar + 1; 는 값을 바꾼게 아니라서 가능
		// 쟤는 증가시킨 다음에 바꾸려 하는거라 error

	p += 1; //가능. 포인터는 주소를 가질 수 있는 변수라 얼마든지 값을 바꿀 수 있음.

	// ++ar;는 error
	++p; //가능. 포인터 p가 가리키는 값은 2번인덱스 공간. 주소를 두번 올림
	cout << *p << endl;

}
